<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/DroneConnection.js | minidrone-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Parrot Minidrone library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="minidrone-js"><meta property="twitter:description" content="Parrot Minidrone library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Mechazawa/minidrone-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CommandParser.js~CommandParser.html">CommandParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DroneCommand.js~DroneCommand.html">DroneCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DroneCommandArgument.js~DroneCommandArgument.html">DroneCommandArgument</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DroneConnection.js~DroneConnection.html">DroneConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/InvalidCommandError.js~InvalidCommandError.html">InvalidCommandError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#util">util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/Enum.js~Enum.html">Enum</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/DroneConnection.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import EventEmitter from &apos;events&apos;;
import Logger from &apos;winston&apos;;
import Enum from &apos;./util/Enum&apos;;
import CommandParser from &apos;./CommandParser&apos;;

const MANUFACTURER_SERIALS = [&apos;4300cf1900090100&apos;, &apos;4300cf1909090100&apos;, &apos;4300cf1907090100&apos;];
const DRONE_PREFIXES = [&apos;RS_&apos;, &apos;Mars_&apos;, &apos;Travis_&apos;, &apos;Maclan_&apos;, &apos;Mambo_&apos;, &apos;Blaze_&apos;, &apos;NewZ_&apos;];

// http://forum.developer.parrot.com/t/minidrone-characteristics-uuid/4686/3
const handshakeUuids = [
  &apos;fb0f&apos;, &apos;fb0e&apos;, &apos;fb1b&apos;, &apos;fb1c&apos;,
  &apos;fd22&apos;, &apos;fd23&apos;, &apos;fd24&apos;, &apos;fd52&apos;,
  &apos;fd53&apos;, &apos;fd54&apos;,
];

// the following UUID segments come from the Mambo and from the documenation at
// http://forum.developer.parrot.com/t/minidrone-characteristics-uuid/4686/3
// the 3rd and 4th bytes are used to identify the service
const serviceUuids = {
  &apos;fa&apos;: &apos;ARCOMMAND_SENDING_SERVICE&apos;,
  &apos;fb&apos;: &apos;ARCOMMAND_RECEIVING_SERVICE&apos;,
  &apos;fc&apos;: &apos;PERFORMANCE_COUNTER_SERVICE&apos;,
  &apos;fd21&apos;: &apos;NORMAL_BLE_FTP_SERVICE&apos;,
  &apos;fd51&apos;: &apos;UPDATE_BLE_FTP&apos;,
  &apos;fe00&apos;: &apos;UPDATE_RFCOMM_SERVICE&apos;,
  &apos;1800&apos;: &apos;Device Info&apos;,
  &apos;1801&apos;: &apos;unknown&apos;,
};

// the following characteristic UUID segments come from the documentation at
// http://forum.developer.parrot.com/t/minidrone-characteristics-uuid/4686/3
// the 4th bytes are used to identify the characteristic
// the types of commands and data coming back are also documented here
// http://forum.developer.parrot.com/t/ble-characteristics-of-minidrones/5912/2
const characteristicReceiveUuids = new Enum({
  &apos;ACK_DRONE_DATA&apos;: &apos;0e&apos;, // drone data that needs an ack (needs to be ack on 1e)
  &apos;NO_ACK_DRONE_DATA&apos;: &apos;0f&apos;, // data from drone (including battery and others), no ack
  &apos;ACK_COMMAND_SENT&apos;: &apos;1b&apos;, // ack 0b channel, SEND_WITH_ACK
  &apos;ACK_HIGH_PRIORITY&apos;: &apos;1c&apos;, // ack 0c channel, SEND_HIGH_PRIORITY
});

/**
 * Drone connection class
 *
 * Exposes an api for controlling the drone
 *
 * @fires DroneCommand#connected
 * @fires DroneCommand#sensor:
 * @property {CommandParser} parser - {@link CommandParser} instance
 */
export default class DroneConnection extends EventEmitter {
  /**
   * Creates a new DroneConnection instance
   * @param {string} [droneFilter=] - The drone name leave blank for no filter
   * @param {boolean} [warmup=true] - Warmup the command parser
   */
  constructor(droneFilter = &apos;&apos;, warmup = true) {
    super();

    this.characteristics = [];

    this._characteristicLookupCache = {};
    this._commandCallback = {};
    this._sensorStore = {};
    this._stepStore = {};

    this.droneFilter = droneFilter;

    // Noble returns an instance when you require
    // it. So we need to prevent webpack from
    // pre-loading it.
    // eslint-disable-next-line no-eval
    this.noble = eval(&apos;require(\&apos;noble\&apos;)&apos;);
    this.parser = new CommandParser();

    if (warmup) {
      // We&apos;ll do it for you so you don&apos;t have to
      this.parser.warmup();
    }

    // bind noble event handlers
    this.noble.on(&apos;stateChange&apos;, state =&gt; this._onNobleStateChange(state));
    this.noble.on(&apos;discover&apos;, peripheral =&gt; this._onPeripheralDiscovery(peripheral));
  }

  /**
   * Event handler for when noble broadcasts a state change
   * @param  {String} state a string describing noble&apos;s state
   * @return {undefined}
   * @private
   */
  _onNobleStateChange(state) {
    Logger.debug(`Noble state changed to ${state}`);

    if (state === &apos;poweredOn&apos;) {
      Logger.info(&apos;Searching for drones...&apos;);
      this.noble.startScanning();
    }
  }

  /**
   * Event handler for when noble discovers a peripheral
   * Validates it is a drone and attempts to connect.
   *
   * @param {Peripheral} peripheral a noble peripheral class
   * @return {undefined}
   * @private
   */
  _onPeripheralDiscovery(peripheral) {
    if (!this._validatePeripheral(peripheral)) {
      return;
    }

    Logger.info(`Peripheral found ${peripheral.advertisement.localName}`);

    this.noble.stopScanning();

    peripheral.connect((error) =&gt; {
      if (error) {
        throw error;
      }
      this._peripheral = peripheral;

      this._setupPeripheral();
    });
  }

  /**
   * Validates a noble Peripheral class is a Parrot MiniDrone
   * @param {Peripheral} peripheral a noble peripheral object class
   * @return {boolean} If the peripheral is a drone
   * @private
   */
  _validatePeripheral(peripheral) {
    if (!peripheral) {
      return false;
    }

    const localName = peripheral.advertisement.localName;
    const manufacturer = peripheral.advertisement.manufacturerData;
    const matchesFilter = !this.droneFilter || localName === this.droneFilter;

    const localNameMatch = matchesFilter || DRONE_PREFIXES.some((prefix) =&gt; localName &amp;&amp; localName.indexOf(prefix) &gt;= 0);
    const manufacturerMatch = manufacturer &amp;&amp; MANUFACTURER_SERIALS.indexOf(manufacturer) &gt;= 0;

    // Is TRUE according to droneFilter or if empty, for EITHER an &quot;RS_&quot; name OR manufacturer code.
    return localNameMatch || manufacturerMatch;
  }

  /**
   * Sets up a peripheral and finds all of it&apos;s services and characteristics
   * @return {undefined}
   */
  _setupPeripheral() {
    this.peripheral.discoverAllServicesAndCharacteristics((err, services, characteristics) =&gt; {
      if (err) {
        throw err;
      }

      // @todo
      // Parse characteristics and only store the ones needed
      // also validate that they&apos;re also present
      this.characteristics = characteristics;

      Logger.debug(&apos;Preforming handshake&apos;);
      for (const uuid of handshakeUuids) {
        const target = this.getCharacteristic(uuid);

        target.subscribe();
      }

      Logger.debug(&apos;Adding listeners&apos;);
      for (const uuid of characteristicReceiveUuids.values()) {
        const target = this.getCharacteristic(&apos;fb&apos; + uuid);

        target.subscribe();
        target.on(&apos;data&apos;, data =&gt; this._handleIncoming(uuid, data));
      }

      Logger.info(`Device connected ${this.peripheral.advertisement.localName}`);

      setTimeout(() =&gt; {
        /**
         * Drone connected event
         * You can control the drone once this event has been triggered.
         *
         * @event DroneCommand#connected
         */
        this.emit(&apos;connected&apos;);
      }, 200);
    });
  }

  /**
   * @returns {Peripheral} a noble peripheral object class
   */
  get peripheral() {
    return this._peripheral;
  }

  /**
   * @returns {boolean} If the drone is connected
   */
  get connected() {
    return this.characteristics.length &gt; 0;
  }

  /**
   * Finds a Noble Characteristic class for the given characteristic UUID
   * @param {String} uuid The characteristics UUID
   * @return {Characteristic} The Noble Characteristic corresponding to that UUID
   */
  getCharacteristic(uuid) {
    uuid = uuid.toLowerCase();

    if (typeof this._characteristicLookupCache[uuid] === &apos;undefined&apos;) {
      this._characteristicLookupCache[uuid] = this.characteristics.find(x =&gt; x.uuid.substr(4, 4).toLowerCase() === uuid);
    }

    return this._characteristicLookupCache[uuid];
  }

  /**
   * Send a command to the drone and execute it
   * @param {DroneCommand} command - Command instance to be ran
   */
  runCommand(command) {
    Logger.debug(&apos;SEND: &apos;, command.toString());

    const buffer = command.toBuffer();
    const messageId = this._getStep(command.bufferType);

    buffer.writeUInt16LE(messageId, 1);

    this.getCharacteristic(command.sendCharacteristicUuid).write(buffer, true);
  }

  /**
   * Handles incoming data from the drone
   * @param {string} channelUuid - The channel uuid
   * @param {Buffer} buffer - The packet data
   * @private
   */
  _handleIncoming(channelUuid, buffer) {
    const channel = characteristicReceiveUuids.findForValue(channelUuid);
    let callback;

    switch (channel) {
      case &apos;ACK_DRONE_DATA&apos;:
        // We need to response with an ack
        this._updateSensors(buffer.slice(2), true);
        break;
      case &apos;NO_ACK_DRONE_DATA&apos;:
        this._updateSensors(buffer.slice(2), false);
        break;
      case &apos;ACK_COMMAND_SENT&apos;:
      case &apos;ACK_HIGH_PRIORITY&apos;:
        callback = this._commandCallback[channel];

        delete this._commandCallback[channel];

        if (typeof callback === &apos;function&apos;) {
          callback();
        }

        break;
      default:
        Logger.warn(`Got data on an unknown channel ${channel} (wtf!?)`);
        break;
    }
  }

  /**
   * Update the sensor
   *
   * @param {Buffer} buffer - Buffer containing just the command info
   * @param {boolean} ack - If an acknowledgement for receiving the data should be sent
   * @private
   * @fires DroneConnection#sensor:
   * @todo implement ack
   */
  _updateSensors(buffer, ack = false) {
    if (buffer[0] === 0) {
      return;
    }

    try {
      const command = this._parser.parseBuffer(buffer);
      const token = [command.projectName, command.className, command.commandName].join(&apos;-&apos;);

      this._sensorStore[token] = command;

      Logger.debug(&apos;RECV:&apos;, command.toString());

      /**
       * Fires when a new sensor reading has been received
       *
       * @event DroneConnection#sensor:
       * @type {DroneCommand} - The sensor reading
       * @example
       * connection.on(&apos;sensor:minidrone-UsbAccessoryState-GunState&apos;, function(sensor) {
       *  if (sensor.state.value === sensor.state.enum.READY) {
       *    console.log(&apos;The gun is ready to fire!&apos;);
       *  }
       * });
       */
      this.emit(&apos;sensor:&apos; + token, command);
      this.emit(&apos;sensor:*&apos;, command);
    } catch (e) {
      Logger.warn(&apos;Unable to parse packet:&apos;, buffer);
      Logger.warn(e);
    }
  }

  /**
   * Get the most recent sensor reading
   *
   * @param {string} project - Project name
   * @param {string} class_ - Class name
   * @param {string} command - Command name
   * @returns {DroneCommand|undefined} - {@link DroneCommand} instance or {@link undefined} if no sensor reading could be found
   * @see {@link https://github.com/Parrot-Developers/arsdk-xml/blob/master/xml/}
   */
  getSensor(project, class_, command) {
    const token = [project, class_, command].join(&apos;-&apos;);

    return this.getSensorFromToken(token);
  }

  /**
   * Get the most recent sensor reading using the sensor token
   *
   * @param {string} token - Command token
   * @returns {DroneCommand|undefined} - {@link DroneCommand} instance or {@link undefined} if no sensor reading could be found
   * @see {@link https://github.com/Parrot-Developers/arsdk-xml/blob/master/xml/}
   * @see {@link DroneCommand.getToken}
   */
  getSensorFromToken(token) {
    let command = this._sensorStore[token];

    if (command) {
      command = command.copy();
    }

    return command;
  }

  /**
   * Get the logger level
   * @returns {string|number} - logger level
   * @see {@link https://github.com/winstonjs/winston}
   */
  get logLevel() {
    return Logger.level;
  }

  /**
   * Set the logger level
   * @param {string|number} value - logger level
   * @see {@link https://github.com/winstonjs/winston}
   */
  set logLevel(value) {
    Logger.level = typeof value === &apos;number&apos; ? value : value.toString();
  }

  /**
   * used to count the drone command steps
   * @param {string} id - Step store id
   * @returns {number}
   */
  _getStep(id) {
    if (typeof this._stepStore[id] === &apos;undefined&apos;) {
      this._stepStore[id] = 0;
    }

    const out = this._stepStore[id];

    this._stepStore[id] = this._stepStore[id] + 1 &amp; 0xFF;

    return out;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
