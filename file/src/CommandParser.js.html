<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/CommandParser.js | minidrone-js</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Parrot Minidrone library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="minidrone-js"><meta property="twitter:description" content="Parrot Minidrone library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Mechazawa/minidrone-js"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/CommandParser.js~CommandParser.html">CommandParser</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DroneCommand.js~DroneCommand.html">DroneCommand</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DroneCommandArgument.js~DroneCommandArgument.html">DroneCommandArgument</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/DroneConnection.js~DroneConnection.html">DroneConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/InvalidCommandError.js~InvalidCommandError.html">InvalidCommandError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#util">util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/Enum.js~Enum.html">Enum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getTypeName">getTypeName</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/CommandParser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { parseString } from &apos;xml2js&apos;;
import DroneCommand from &apos;./DroneCommand&apos;;
import Logger from &apos;winston&apos;;
import InvalidCommandError from &apos;./InvalidCommandError&apos;;

const _fileCache = {};
const _commandCache = {};

/**
 * Command parser used for looking up commands in the xml definition
 */
export default class CommandParser {
  /**
   * Get an xml file and convert it to json
   * @param {string} name - Project name
   * @returns {Object} - Parsed Xml data using xml2js
   * @private
   */
  _getXml(name) {
    const file = CommandParser._fileMapping[name];

    if (typeof file === &apos;undefined&apos;) {
      throw new Error(`Xml file ${name} could not be found`);
    }

    if (typeof _fileCache[name] === &apos;undefined&apos;) {
      _fileCache[name] = null;

      parseString(file, { async: false }, (e, result) =&gt; {
        _fileCache[name] = result;
      });

      return this._getXml(name);
    } else if (_fileCache[name] === null) {
      // Fuck javascript async hipster shit
      return this._getXml(name);
    }

    return _fileCache[name];
  }

  /**
   * Used for file loading/lookup
   * @returns {{minidrone: string, common: string}} - xml files with contents
   * @private
   */
  static get _fileMapping() {
    return {
      minidrone: require(&apos;arsdk-xml/xml/minidrone.xml&apos;),
      common: require(&apos;arsdk-xml/xml/common.xml&apos;),
    };
  }

  /**
   * Get a list of available files
   * @returns {string[]} - Available files
   * @private
   */
  static get _files() {
    return Object.keys(CommandParser._fileMapping);
  }

  /**
   * Get a command based on it&apos;s path in the xml definition
   * @param {string} projectName - The xml file name (project name)
   * @param {string} className - The command class name
   * @param {string} commandName - The command name
   * @param {Object?} commandArguments - Optional command arguments
   * @returns {DroneCommand} - Target command
   * @throws InvalidCommandError
   * @see {@link https://github.com/Parrot-Developers/arsdk-xml/blob/master/xml/}
   * @example
   * const parser = new CommandParser();
   * const backFlip = parser.getCommand(&apos;minidrone&apos;, &apos;Animations&apos;, &apos;Flip&apos;, {direction: &apos;back&apos;});
   */
  getCommand(projectName, className, commandName, commandArguments = {}) {
    const cacheToken = [
      projectName, className,
      commandName,
    ].join(&apos;-&apos;);

    if (typeof _commandCache[cacheToken] === &apos;undefined&apos;) {
      const project = this._getXml(projectName).project;

      this._assertElementExists(project, &apos;project&apos;, projectName);

      const context = [projectName];

      const targetClass = project.class.find(v =&gt; v.$.name === className);

      this._assertElementExists(targetClass, &apos;class&apos;, className);

      context.push(className);

      const targetCommand = targetClass.cmd.find(v =&gt; v.$.name === commandName);

      this._assertElementExists(targetCommand, &apos;command&apos;, commandName);

      const result = new DroneCommand(project, targetClass, targetCommand);

      _commandCache[cacheToken] = result;

      if (result.deprecated) {
        Logger.warn(`${result.toString()} has been deprecated`);
      }
    }

    const target = _commandCache[cacheToken].clone();

    for (const arg of Object.keys(commandArguments)) {
      if (target.hasArgument(arg)) {
        target[arg] = commandArguments[arg];
      }
    }

    return target;
  }

  /**
   * Gets the command by analysing the buffer
   * @param {Buffer} buffer - Command buffer without leading 2 bytes
   * @returns {DroneCommand} - Buffer&apos;s related DroneCommand
   * @private
   */
  _getCommandFromBuffer(buffer) {
    const projectId = buffer.readUInt8(0);
    const classId = buffer.readUInt8(1);
    const commandId = buffer.readUInt8(2);

    const cacheToken = [projectId, classId, commandId].join(&apos;-&apos;);

    // Build command if needed
    if (typeof _commandCache[cacheToken] === &apos;undefined&apos;) {
      // Find project
      const project = CommandParser._files
        .map(x =&gt; this._getXml(x).project)
        .find(x =&gt; Number(x.$.id) === projectId);

      this._assertElementExists(project, &apos;project&apos;, projectId);

      // find class
      const targetClass = project.class.find(x =&gt; Number(x.$.id) === classId);

      const context = [project.$.name];

      this._assertElementExists(targetClass, &apos;class&apos;, classId, context);

      // find command
      const targetCommand = targetClass.cmd.find(x =&gt; Number(x.$.id) === commandId);

      context.push(targetClass.$.name);

      this._assertElementExists(targetCommand, &apos;command&apos;, commandId, context);

      // Build command and store it
      _commandCache[cacheToken] = new DroneCommand(project, targetClass, targetCommand);
    }

    return _commandCache[cacheToken].clone();
  }

  /**
   * Parse the input buffer and get the correct command with parameters
   * Used internally to parse sensor data
   * @param {Buffer} buffer - The command buffer without the first two bytes
   * @returns {DroneCommand} - Parsed drone command
   * @throws InvalidCommandError
   * @throws TypeError
   */
  parseBuffer(buffer) {
    const command = this._getCommandFromBuffer(buffer);

    let bufferOffset = 3;

    for (const arg of command.arguments) {
      let valueSize = arg.getValueSize();
      let value = 0;

      switch (arg.type) {
        case &apos;u8&apos;:
        case &apos;u16&apos;:
        case &apos;u32&apos;:
        case &apos;u64&apos;:
          value = buffer.readUIntLE(bufferOffset, valueSize);
          break;
        case &apos;i8&apos;:
        case &apos;i16&apos;:
        case &apos;i32&apos;:
        case &apos;i64&apos;:
          value = buffer.readIntLE(bufferOffset, valueSize);
          break;
        case &apos;enum&apos;:
          // @todo figure out why I have to do this
          value = buffer.readIntLE(bufferOffset + 1, valueSize - 1);
          break;
        // eslint-disable-next-line no-case-declarations
        case &apos;string&apos;:
          value = &apos;&apos;;
          let c = &apos;&apos;; // Last character

          for (valueSize = 0; valueSize &lt; buffer.length &amp;&amp; c !== &apos;\0&apos;; valueSize++) {
            c = String.fromCharCode(buffer[bufferOffset]);

            value += c;
          }
          break;
        case &apos;float&apos;:
          value = buffer.readFloatBE(bufferOffset);
          break;
        case &apos;double&apos;:
          value = buffer.readDoubleLE(bufferOffset);
          break;
        default:
          throw new TypeError(`Can&apos;t parse buffer: unknown data type &quot;${arg.type}&quot; for argument &quot;${arg.name}&quot; in ${command.getToken()}`);
      }

      arg.value = value;

      bufferOffset += valueSize;
    }

    return command;
  }

  /**
   * Warn up the parser by pre-fetching the xml files
   * @returns {void}
   */
  warmup() {
    CommandParser._files.forEach(file =&gt; this._getXml(file));
  }

  /**
   * helper method
   * @param {Object|undefined} value - Xml node value
   * @param {string} type - Xml node type
   * @param {string|number} target - Xml node value
   * @param {Array&lt;Object|undefined&gt;} context - Parser context
   * @private
   * @throws InvalidCommandError
   * @returns {void}
   */
  _assertElementExists(value, type, target, context = []) {
    if (typeof value === &apos;undefined&apos;) {
      throw new InvalidCommandError(value, type, target, context);
    }
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.0.4)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
